<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>React组件的生命周期（一） | WangJunMing</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="React 生命周期，对于 React 开发者而言，可以说刻到了 DNA 都不为过。但就是这样一个老生长谈的话题，很多入门资料对于其介绍，大都是一个一个生命周期列出来，说一下怎么用，泛泛而过。这样的教学，导致很多入门者，对于 React 组件生命周期的印象就是，“背就完了，别想太多”。

“背就完了”，可能能让我们知道“What to do”，进而达到“How to do”，却不能帮助我们理解“W ...">
    
    <link rel="preload" href="/assets/css/0.styles.89986362.css" as="style"><link rel="preload" href="/assets/js/app.0f8cdf39.js" as="script"><link rel="preload" href="/assets/js/6.a3faf424.js" as="script"><link rel="preload" href="/assets/js/3.c93107eb.js" as="script"><link rel="preload" href="/assets/js/53.fcfc593b.js" as="script"><link rel="prefetch" href="/assets/js/10.e536da9a.js"><link rel="prefetch" href="/assets/js/11.811a1c66.js"><link rel="prefetch" href="/assets/js/12.03f8ea6c.js"><link rel="prefetch" href="/assets/js/13.fe6a5fa3.js"><link rel="prefetch" href="/assets/js/14.4e95d46b.js"><link rel="prefetch" href="/assets/js/15.7afe0bf8.js"><link rel="prefetch" href="/assets/js/16.df6d6836.js"><link rel="prefetch" href="/assets/js/17.652cf3e7.js"><link rel="prefetch" href="/assets/js/18.eb0177a9.js"><link rel="prefetch" href="/assets/js/19.00998b11.js"><link rel="prefetch" href="/assets/js/20.5c68c241.js"><link rel="prefetch" href="/assets/js/21.410819d5.js"><link rel="prefetch" href="/assets/js/22.e8d9d6c8.js"><link rel="prefetch" href="/assets/js/23.5137aa0a.js"><link rel="prefetch" href="/assets/js/24.917d2b73.js"><link rel="prefetch" href="/assets/js/25.97536c59.js"><link rel="prefetch" href="/assets/js/26.13c04086.js"><link rel="prefetch" href="/assets/js/27.84b1618e.js"><link rel="prefetch" href="/assets/js/28.ea0c286e.js"><link rel="prefetch" href="/assets/js/29.e1cd6541.js"><link rel="prefetch" href="/assets/js/30.63254da6.js"><link rel="prefetch" href="/assets/js/31.3e7d0ff4.js"><link rel="prefetch" href="/assets/js/32.68e1c30b.js"><link rel="prefetch" href="/assets/js/33.e2609257.js"><link rel="prefetch" href="/assets/js/34.6ead8fc3.js"><link rel="prefetch" href="/assets/js/35.19fdd4f5.js"><link rel="prefetch" href="/assets/js/36.26db6628.js"><link rel="prefetch" href="/assets/js/37.85b6206b.js"><link rel="prefetch" href="/assets/js/38.61d14197.js"><link rel="prefetch" href="/assets/js/39.e8ef2b39.js"><link rel="prefetch" href="/assets/js/4.0c3bd0d6.js"><link rel="prefetch" href="/assets/js/40.28d383f1.js"><link rel="prefetch" href="/assets/js/41.a4dec16c.js"><link rel="prefetch" href="/assets/js/42.b470391d.js"><link rel="prefetch" href="/assets/js/43.1f7c3205.js"><link rel="prefetch" href="/assets/js/44.4b88ce68.js"><link rel="prefetch" href="/assets/js/45.67613782.js"><link rel="prefetch" href="/assets/js/46.ee13fff6.js"><link rel="prefetch" href="/assets/js/47.31e29740.js"><link rel="prefetch" href="/assets/js/48.9a033329.js"><link rel="prefetch" href="/assets/js/49.74f307ca.js"><link rel="prefetch" href="/assets/js/5.264a5b6a.js"><link rel="prefetch" href="/assets/js/50.4a964ec2.js"><link rel="prefetch" href="/assets/js/51.a9e21b82.js"><link rel="prefetch" href="/assets/js/52.d1d7da25.js"><link rel="prefetch" href="/assets/js/54.40d902ab.js"><link rel="prefetch" href="/assets/js/55.797c16c8.js"><link rel="prefetch" href="/assets/js/7.4f6e89b1.js"><link rel="prefetch" href="/assets/js/8.727d7cfc.js"><link rel="prefetch" href="/assets/js/9.d50e5524.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.0f8d5620.js">
    <link rel="stylesheet" href="/assets/css/0.styles.89986362.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">WangJunMing </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">WangJunMing </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        React组件的生命周期（一）
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">WangJunMing</span> <span itemprop="address">   in ShangHai</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-08-10T00:00:00.000Z">
      Mon Aug 10 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/JS" data-v-42ccfcd5><span data-v-42ccfcd5>JS</span></a></li><li class="post-tag" data-v-42ccfcd5><a href="/tag/React" data-v-42ccfcd5><span data-v-42ccfcd5>React</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>React 生命周期，对于 React 开发者而言，可以说刻到了 DNA 都不为过。但就是这样一个老生长谈的话题，很多入门资料对于其介绍，大都是一个一个生命周期列出来，说一下怎么用，泛泛而过。这样的教学，导致很多入门者，对于 React 组件生命周期的印象就是，“背就完了，别想太多”。</p> <p>“背就完了”，可能能让我们知道“What to do”，进而达到“How to do”，却不能帮助我们理解“Why to do”。</p> <p>React15 和 React16 两个版本，组件的生命周期又进行了变动。我们应当从 React 的基本原理出发，对比这两个版本组件生命周期的异同，认真探寻 React 组件的生命周期设计哲学。通过搞清楚一个又一个的“Why”，帮助自己建立系统而完善的生命周期知识体系。</p> <h2 id="react-设计的核心点"><a href="#react-设计的核心点" class="header-anchor">#</a> React 设计的核心点</h2> <p>如果我们常翻阅 React 官网或者 React 官方的一些文章，你会发现“组件”和“虚拟 DOM”这两个词的出镜率是非常高的，它们是 React 基本原理中极为关键的两个概念。</p> <h3 id="虚拟-dom-核心算法的基石"><a href="#虚拟-dom-核心算法的基石" class="header-anchor">#</a> 虚拟 DOM：核心算法的基石</h3> <p>组件在初始化时，会通过调用生命周期中的 render 方法，生成虚拟 DOM，然后再通过调用 ReactDOM.render 方法，实现虚拟 DOM 到真实 DOM 的转换。</p> <p>当组件更新时，会再次通过调用 render 方法生成新的虚拟 DOM，然后借助 diff 算法定位出两次虚拟 DOM 的差异，从而针对发生变化的真实 DOM 作定向更新。</p> <p>以上就是 React 框架核心算法的大致流程。对于这套关键的工作流来说，“虚拟 DOM”是所有操作的大前提，是核心算法的基石。</p> <h3 id="组件化编程"><a href="#组件化编程" class="header-anchor">#</a> 组件化编程</h3> <p>组件化是一种优秀的软件设计思想，也是 React 团队在研发效能方面所做的一个重要的努力。</p> <p>在一个 React 项目中，几乎所有的可见/不可见的内容都可以被抽离为各种各样的组件，每个组件既是“封闭”的，也是“开放”的。</p> <p>所谓“封闭”，主要是针对“渲染工作流”（指从组件数据改变到组件实际更新发生的过程）来说的。在组件自身的渲染工作流中，每个组件都只处理它内部的渲染逻辑。在没有数据流交互的情况下，组件与组件之间可以做到“各自为政”。</p> <p>而所谓“开放”，则是针对组件间通信来说的。React 允许开发者基于“单向数据流”的原则完成组件间的通信。而组件之间的通信又将改变通信双方/某一方内部的数据，进而对渲染结果构成影响。所以说在数据这个“通讯员”的牵线搭桥之下，组件之间又是彼此开放的，是可以相互影响的。</p> <p>这一“开放”与“封闭”兼具的特性，使得 React 组件既专注又灵活，具备高度的可重用性和可维护性。</p> <h2 id="生命周期方法的本质-组件的-灵魂-与-躯干"><a href="#生命周期方法的本质-组件的-灵魂-与-躯干" class="header-anchor">#</a> 生命周期方法的本质：组件的“灵魂”与“躯干”</h2> <p>曾有人将 React 组件的 render 方法比喻程 React 组件的灵魂，因为 render 描述了 React 组件是怎样的。前面说到的虚拟 DOM、组件化，全是在围绕着<code>render</code>在工作：虚拟 DOM 自然不必多说，需要 render 来生成；而组件化概念中所提及的“渲染工作流”，这里指的是从组件数据改变到组件实际更新发生的过程，这个过程的实现同样离不开 render。</p> <p>从这个比喻出发，render 是组件的灵魂，那各生命周期方法就可以理解为组件的躯干了。</p> <p>“躯干”未必总是会做具体的事情（比如说我们可以选择性地省略对 render 之外的任何生命周期方法内容的编写），而“灵魂”却总是充实的（render 函数却坚决不能省略）；倘若“躯干”做了点什么，往往都会直接或间接地影响到“灵魂”（因为即便是 render 之外的生命周期逻辑，也大部分是在为 render 层面的效果服务）；“躯干”和“灵魂”一起，共同构成了 React 组件完整而不可分割的“生命时间轴”。</p> <h2 id="拆解生命周期-从-react15-聊聊"><a href="#拆解生命周期-从-react15-聊聊" class="header-anchor">#</a> 拆解生命周期，从 React15 聊聊</h2> <p>因为 React16 甚至 React17 的快步跑进，现在很多资料在讲解 React 生命周期时，直接从 16 开始。这样做虽然省事，但也模糊掉了 React15 和 React16 之间的不同，无法帮助我们理解这变动后的 why。</p> <p>为了理解这两个版本生命周期变动的 why，我们先来看看 React15 之中，那些常用的生命周期，如下</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentWillReceiveProps</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">shouldComponentUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentWillMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentDidMount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentWillUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentDidUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">componentWillUnmount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>React15 中，组件的生命周期可分为三个阶段：挂载，更新，卸载。</p> <h2 id="挂载阶段"><a href="#挂载阶段" class="header-anchor">#</a> 挂载阶段</h2> <p>在挂载阶段，一个 React 组件的生命周期会按照如下顺序调用：组件挂载（初始化渲染）=》constructor()=》componentWillMount() =》render() =&gt; componentDidMount()</p> <p>首先我们来看 constructor 方法，该方法仅仅在挂载的时候被调用一次，我们可以在该方法中对 this.state 进行初始化：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;进入constructor&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// state 可以在 constructor 里初始化</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span> text<span class="token operator">:</span> <span class="token string">&quot;子组件的文本&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>componentWillMount、componentDidMount 方法同样只会在挂载阶段被调用一次。其中 componentWillMount 会在执行 render 方法前被触发，有些开发者习惯在这个方法里做一些初始化的操作，但这些操作往往会伴随一些风险或者说不必要性。</p> <p>接下来 render 方法被触发。注意 render 在执行过程中并不会去操作真实 DOM（也就是说不会渲染），它的职能是把需要渲染的内容返回出来。真实 DOM 的渲染工作，在挂载阶段是由 ReactDOM.render 来承接的。</p> <p>componentDidMount 方法在渲染结束后被触发，此时因为真实 DOM 已经挂载到了页面上，我们可以在这个生命周期里执行真实 DOM 相关的操作。此外，类似于异步请求、数据初始化这样的操作也大可以放在这个生命周期来做（侧面印证了 componentWillMount 真的很鸡肋）。</p> <h2 id="组件更新阶段"><a href="#组件更新阶段" class="header-anchor">#</a> 组件更新阶段</h2> <p>组件的更新分为两种：一种是由父组件触发的更新；另一种就是组件自身调用的 setState 触发的更新。</p> <p>首先看组件自身 setState 触发的更新，会走哪些生命周期：shouldComponentUpdate() =》componentWiiUpdate() =》 render() =》componentDidUpdate()</p> <p>而父组件触发的组件更新，会在最前面多走一个生命周期：componentWillReceiveProps(nextProps) =》shouldComponentUpdate() =》componentWiiUpdate() =》 render() =》componentDidUpdate()</p> <p>在这个<code>componentWillReceiveProps(nextProps)</code>里，nextProps 表示的是接收到新 props 内容，而现有的 props （相对于 nextProps 的“旧 props”）我们可以通过 this.props 拿到，由此便能够感知到 props 的变化。</p> <p><code>componentWillReceiveProps(nextProps)</code>执行时机，还有一个误区--很多开发者以为，<strong>componentWillReceiveProps 是在组件的 props 内容发生了变化时被触发的。</strong>。这种说法是不够严谨的，实际上，<strong>只要父组件更新了，子组件就算接收到 props 没有变化，自组件跟着更新的时候，也会走<code>componentWillReceiveProps(nextProps)</code>。</strong></p> <p>而这个，在 React 官方文档中也有提及的</p> <blockquote><p>如果父组件导致组件重新渲染，即使 props 没有发生变化，也会调用此方法(componentReceiveProps)。如果只想处理更改，请确保进行当前值与变更值的比较。</p></blockquote> <p>所以，严谨的说法应该是<strong>componentReceiveProps 并不是由 props 的变化触发的，而是由父组件的更新触发的。</strong></p> <p>再来说<code>componentWillUpdate</code>和<code>componentDidUpdate</code>这对好哥们。</p> <p>componentWillUpdate 会在 render 前被触发，它和 componentWillMount 类似，允许你在里面做一些不涉及真实 DOM 操作的准备工作；而 componentDidUpdate 则在组件更新完毕后被触发，和 componentDidMount 类似，这个生命周期也经常被用来处理 DOM 操作。此外，我们也常常将 componentDidUpdate 的执行作为子组件更新完毕的标志通知到父组件。</p> <p>至于**<code>shouldComponentUpdate</code>**这个方法，对于 React 开发者更是亲切的老朋友了。因为它常常用来做 render 的性能优化。</p> <p>render 方法由于伴随着对虚拟 DOM 的构建和对比，过程可以说相当耗时。而在 React 当中，很多时候我们会不经意间就频繁地调用了 render。为了避免不必要的 render 操作带来的性能开销，React 为我们提供了 shouldComponentUpdate 这个口子。</p> <p>React 组件会根据 shouldComponentUpdate 的返回值，来决定是否执行该方法之后的生命周期，进而决定是否对组件进行 re-render（重渲染）。shouldComponentUpdate 的默认值为 true，也就是说“无条件 re-render”。在实际的开发中，我们往往通过手动往 shouldComponentUpdate 中填充判定逻辑，或者直接在项目中引入 PureComponent 等最佳实践，来实现“有条件的 re-render”。</p> <h2 id="组件卸载阶段"><a href="#组件卸载阶段" class="header-anchor">#</a> 组件卸载阶段</h2> <p>组件卸载阶段的生命周期函数，就可简单了，只有一个<code>componentWillUnmount</code>。</p> <p>这个生命周期本身不难理解，重点关注怎么触发它。组件销毁的常见原因有以下两个：</p> <ol><li>组件在父组件中被移除了；</li> <li>组件中设置了 key 属性，父组件在 render 的过程中，发现 key 值和上一次不一致，那么这个组件就会被干掉。</li></ol> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>虚拟 DOM 和组件化是 React 的关键概念，简单地做了整理。</p> <p>在 React15 版本中，梳理了常用的生命周期，进行了系统性的学习。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#react-设计的核心点" title="React 设计的核心点">React 设计的核心点</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#虚拟-dom-核心算法的基石" title="虚拟 DOM：核心算法的基石">虚拟 DOM：核心算法的基石</a></div><div class="vuepress-toc-item vuepress-toc-h3"><a href="#组件化编程" title="组件化编程">组件化编程</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#生命周期方法的本质-组件的-灵魂-与-躯干" title="生命周期方法的本质：组件的“灵魂”与“躯干”">生命周期方法的本质：组件的“灵魂”与“躯干”</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#拆解生命周期-从-react15-聊聊" title="拆解生命周期，从 React15 聊聊">拆解生命周期，从 React15 聊聊</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#挂载阶段" title="挂载阶段">挂载阶段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组件更新阶段" title="组件更新阶段">组件更新阶段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#组件卸载阶段" title="组件卸载阶段">组件卸载阶段</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#小结" title="小结">小结</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.0f8cdf39.js" defer></script><script src="/assets/js/6.a3faf424.js" defer></script><script src="/assets/js/3.c93107eb.js" defer></script><script src="/assets/js/53.fcfc593b.js" defer></script>
  </body>
</html>
