---
title: 说说js的作用域链和闭包
date: 2018-04-05
author: WangJunMing
location: HangZhou
tags:
  - JavaScript
---

闭包是 js 中让人津津乐道的一个概念，浏览各类技术博客，闭包这个词在存在繁多花哨的解释。有时候概念看多了，容易把自己弄迷糊，所以这次就自己梳理一下思路，来讲讲 js 中的闭包。

## 作用域和作用域链

要说闭包，那就得理解作用域和作用域链。作用域和作用域链是所有编程语言的基础，要学好一门语言，作用域和作用域链一定是绕不开的。

先看一个简单的例子

```js
function bar() {
  console.log(name);
}
function foo() {
  var name = 'foo';
  bar();
}
var name = 'window';
foo();
```

这段代码里，就包含了三个作用域：bar 函数作用域，foo 函数作用域，全局作用域。

js 在执行时，会创造执行上下文，对应每个作用域，所以这里又有三个执行上下文：bar 函数执行上下文，foo 函数执行上下文，全局执行上下文。

在每个执行上下文的变量环境中，都包含了一个外部引用，用来执行外部的执行上下文，我们把外部的引用称为`outer`。

而我们写的例子里，各执行上下文变量的`outer`指向，则是这样的

![js-chain][./.vuepress/public/images/js-chain.png]

从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。

现在我们知道变量是通过作用域链来查找的了，不过还有一个疑问没有解开，foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？

要回答这个问题，我们还需要知道什么是词法作用域。这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。

## 词法作用域

词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。

概念不够直观，让我们来看一张图

![js-chain][./.vuepress/public/images/js-chain-2.png]

从图可以看出，词法作用域是根据代码的书写位置来决定的。而会带我们写的例子来分析，因无论 bar 函数，还是 foo 函数，都是声明在全局作用域中，所以如果 bar 函数或 foo 函数，使用了一个它们没有声明的变量，都会从全局作用域中去查找。

看得出来，词法作用域是代码编译阶段觉定义好的作用域链，和函数怎么调用是没有关系的。

知道了执行上下文和词法作用域，那我们就知道了，当使用了一个不在当前作用域定义的变量，那 js 引擎就需要沿着作用域链一级一级往上找，如果找不到，就会报错。

看一个变量查找题

```js
function bar() {
  var name = 'bar';
  let test1 = 1;
  if (1) {
    let name = '块级bar';
    console.log(test);
  }
}
function foo() {
  var name = 'foo';
  let test2 = 2;
  {
    let test = '块级test';
    bar();
  }
}
var name = '全局作用域';
let test = 1;
foo(); // 1
```

## 闭包

了解了作用域和作用域链，就可以来学习理解闭包了。

看下面这段代码

```js
function foo() {
  var name = 'foo';
  let test1 = 1;
  const test2 = 2;
  var innerBar = {
    getName: function() {
      console.log(test1);
      return name;
    },
    setName: function(newName) {
      name = newName;
    }
  };
  return innerBar;
}
var var = foo();
bar.setName('bar');
bar.getName();
console.log(bar.getName());
```

innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常我们把对象内部的函数称为方法）。你可以看到，这两个方法都是在 foo 函数内部定义的，并且这两个方法内部都使用了 name 和 test1 两个变量。

根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 name 和 test1。

因为还保持着引用，所以这两个变量不会被垃圾回收，依然保存在内存中。这像极了 setName 和 getName 方法背的一个专属背包，无论在哪里调用了 setName 和 getName 方法，它们都会背着这个 foo 函数的专属背包。

之所以是专属背包，是因为除了 setName 和 getName 函数之外，其他任何地方都是无法访问该背包的，我们就可以把这个背包称为 foo 函数的闭包。

所以，闭包正儿八经的来定概念的话就是：**在 js 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包**

## 闭包是怎么回收的

理解了什么是闭包以后，还得理解闭包什么时候会销毁。毕竟早期浏览器性能不能好的时候，闭包一不小心用多了，就会吃掉浏览器内存，造内存泄漏，使得浏览器崩溃。

通常，假如引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 js 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 js 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，我们尽量要做到：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。

## 小结

了解了什么是作用域链，我们把通过作用域查找变量的链条称为作用域链；作用域链是通过词法作用域来确定的，而词法作用域反映了代码的结构。又跟着学习了，在块级作用域中是如何通过作用域链来查找变量的。

在了解了作用域和作用域链的基础上，再学习了闭包这个概念，以及了解了闭包是如何被回收的。
