(window.webpackJsonp=window.webpackJsonp||[]).push([[40],{514:function(a,t,v){"use strict";v.r(t);var _=v(10),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("p",[a._v("在日常开发中，我们或许需要为页面生成各种酷炫的动画效果，而 CSS 和 JS 都可以做到。那就是随便选就行吗，CSS 动画和 JS 动画有着什么差别呢？")]),a._v(" "),v("p",[a._v("要回答这个问题，就得弄清楚浏览器到底是怎样显示动画的。")]),a._v(" "),v("h2",{attrs:{id:"显示器是怎么显示图像的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#显示器是怎么显示图像的"}},[a._v("#")]),a._v(" 显示器是怎么显示图像的")]),a._v(" "),v("p",[a._v("每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。")]),a._v(" "),v("h2",{attrs:{id:"显卡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#显卡"}},[a._v("#")]),a._v(" 显卡")]),a._v(" "),v("p",[a._v("显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。")]),a._v(" "),v("h2",{attrs:{id:"帧和帧率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#帧和帧率"}},[a._v("#")]),a._v(" 帧和帧率")]),a._v(" "),v("p",[a._v("了解了显示器是怎么显示图像的之后，再来学习下帧和帧率的概念，因为这是后续一切分析的基础。")]),a._v(" "),v("p",[a._v("当我们通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。")]),a._v(" "),v("p",[a._v("大多数设备的显示器的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。")]),a._v(" "),v("p",[a._v("我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。")]),a._v(" "),v("p",[a._v("由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。")]),a._v(" "),v("p",[a._v("要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。")]),a._v(" "),v("h2",{attrs:{id:"如何生成一帧图像"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#如何生成一帧图像"}},[a._v("#")]),a._v(" 如何生成一帧图像")]),a._v(" "),v("p",[a._v("在浏览器中，生成一帧图像的方式有：重排、重绘和合成三种方式。每种方式的渲染路径是不同的。")]),a._v(" "),v("p",[a._v("**通常，渲染路径越长，生成的图像花费时间越长。**就说重排，它需要 DOM 树和 CSSOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。")]),a._v(" "),v("p",[a._v("相比较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果又采用了 GPU，那么合成的效率会非常高。")]),a._v(" "),v("p",[a._v("所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。")]),a._v(" "),v("p",[a._v("那 Chrome 浏览器是怎么实现合成操作的呢？可用三个词来概括：分层、分块和合层。")]),a._v(" "),v("h2",{attrs:{id:"分层和合层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分层和合层"}},[a._v("#")]),a._v(" 分层和合层")]),a._v(" "),v("p",[a._v("通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮时页面滚动的动画效果，当然还有一些炫酷的 3D 动画特效。如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。")]),a._v(" "),v("p",[a._v("为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。")]),a._v(" "),v("p",[a._v("我们可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。如果你熟悉 PhotoShop 的话，就能很好地理解这个过程了，PhotoShop 中一个项目是由很多图层构成的，每个图层都可以是一张单独图片，可以设置透明度、边框阴影，可以旋转或者设置图层的上下位置，将这些图层叠加在一起后，就能呈现出最终的图片了。")]),a._v(" "),v("p",[a._v("在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。")]),a._v(" "),v("p",[a._v("理解了为什么要引入合成和分层机制，下面我们再来看看 Chrome 是怎么实现分层和合成机制的。")]),a._v(" "),v("p",[a._v("在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。")]),a._v(" "),v("p",[a._v("层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。")]),a._v(" "),v("p",[a._v("有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。")]),a._v(" "),v("p",[a._v("需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。")]),a._v(" "),v("h2",{attrs:{id:"分块"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分块"}},[a._v("#")]),a._v(" 分块")]),a._v(" "),v("p",[a._v("如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。")]),a._v(" "),v("p",[a._v("通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。")]),a._v(" "),v("p",[a._v("因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。")]),a._v(" "),v("p",[a._v("为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。")]),a._v(" "),v("h2",{attrs:{id:"利用分层优化代码"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#利用分层优化代码"}},[a._v("#")]),a._v(" 利用分层优化代码")]),a._v(" "),v("p",[a._v("在写 Web 应用的时候，我们可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。")]),a._v(" "),v("p",[a._v("这个时候，我们可以使用"),v("code",[a._v("will-change")]),a._v("这个 CSS 属性告诉渲染引擎，我们会对某个元素做一些特效变化，比如")]),a._v(" "),v("div",{staticClass:"language-css extra-class"},[v("pre",{pre:!0,attrs:{class:"language-css"}},[v("code",[v("span",{pre:!0,attrs:{class:"token selector"}},[a._v(".container")]),a._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),v("span",{pre:!0,attrs:{class:"token property"}},[a._v("will-change")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" transform"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" opacity"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),v("p",[a._v("上面这段代码，就是提前告诉渲染引擎"),v("code",[a._v("container")]),a._v("元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。")]),a._v(" "),v("p",[a._v("所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。")]),a._v(" "),v("h2",{attrs:{id:"小结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),v("p",[a._v("主要学习了显示器显示图像的原理，以及帧和帧率的概念，然后基于帧和帧率我们又介绍渲染引擎是如何实现一帧图像的。通常渲染引擎生成一帧图像有三种方式：重排、重绘和合成。其中重排和重绘操作都是在渲染进程的主线程上执行的，比较耗时；而合成操作是在渲染进程的合成线程上执行的，执行速度快，且不占用主线程。")]),a._v(" "),v("p",[a._v("浏览器实现合成，主要是三个点：分层、分块和合成。")]),a._v(" "),v("p",[a._v("CSS 动画比 JavaScript 动画高效的原因，是因为 CSS 动画是通过合成方式生成，不会影响主线程。我们可以使用 will-change 来优化动画或特效。")])])}),[],!1,null,null,null);t.default=s.exports}}]);