(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{506:function(a,t,e){"use strict";e.r(t);var s=e(10),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("p",[a._v("在 web 项目中，缓存可以说是性能优化中简单高效的一种方式，合理使用缓存策略，可以有效减少网络传输带来的性能损耗。")]),a._v(" "),e("p",[a._v("对于一个数据请求来说，可以分为发起网络请求、后端处理、浏览器响应三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。")]),a._v(" "),e("p",[a._v("接下来的内容中我们将通过以下几个部分来探讨浏览器缓存机制：")]),a._v(" "),e("ul",[e("li",[a._v("缓存位置")]),a._v(" "),e("li",[a._v("缓存策略")]),a._v(" "),e("li",[a._v("实际场景应用缓存策略")])]),a._v(" "),e("h2",{attrs:{id:"_1-缓存位置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-缓存位置"}},[a._v("#")]),a._v(" 1 缓存位置")]),a._v(" "),e("p",[a._v("从缓存位置上来讲，缓存分为四种，并且拥有各自的优先级。当依次查找缓存且没有命中缓存时，才去请求服务器数据")]),a._v(" "),e("p",[a._v("按位置区分这四种缓存分别是")]),a._v(" "),e("ol",[e("li",[a._v("Service Worker")]),a._v(" "),e("li",[a._v("Memory Cache")]),a._v(" "),e("li",[a._v("Disk Cache")]),a._v(" "),e("li",[a._v("Push Cache")])]),a._v(" "),e("h3",{attrs:{id:"_1-1-service-worker"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-service-worker"}},[a._v("#")]),a._v(" 1.1 Service Worker")]),a._v(" "),e("p",[a._v("Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让开发者自由控制缓存哪些文件，如何命中缓存、如何读取缓存，并且它缓存的内容是持续性的。")]),a._v(" "),e("p",[a._v("当 Service Worker 没有命中缓存时，我们需要调用"),e("code",[a._v("fetch")]),a._v("函数去请求数据。也就是说，如果在 Service Worker 中没有命中缓存的话，会根据缓存优先级去查找数据，但是无论浏览器是从 Memory Cache 获取到的数据，还是网络请求获取到的数据，浏览器都会显示是从 Service Worker 中获得的")]),a._v(" "),e("h3",{attrs:{id:"_1-2-memory-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-memory-cache"}},[a._v("#")]),a._v(" 1.2 Memory Cache")]),a._v(" "),e("p",[a._v("Memory Cache 也就是内存中的缓存，读取内存中的数据肯定比磁盘的要快(Disk Cache)。"),e("strong",[a._v("但是内存虽然读取速度快，但是缓存持续性很短，会随着进程的释放而释放")]),a._v("。一旦用户关闭了 tab 页面，内存中的缓存也就被释放了。")]),a._v(" "),e("p",[a._v("平常当我们访问页面后，再次刷新页面时，可以发现很多数据是来自内存缓存。")]),a._v(" "),e("p",[a._v("但是内存容量有限，所以内存虽然可以存储 JS、HTML、CSS、图片等，但是大文件显然不适合存储的。")]),a._v(" "),e("h3",{attrs:{id:"_1-3-disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-disk-cache"}},[a._v("#")]),a._v(" 1.3 Disk Cache")]),a._v(" "),e("p",[a._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")]),a._v(" "),e("p",[a._v("在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。")]),a._v(" "),e("h3",{attrs:{id:"_1-4-push-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-push-cache"}},[a._v("#")]),a._v(" 1.4 Push Cache")]),a._v(" "),e("p",[a._v("Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。")]),a._v(" "),e("p",[a._v("关于它的资料不多，根据网络资料总结有以下几个关键信息")]),a._v(" "),e("ol",[e("li",[a._v("所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好")]),a._v(" "),e("li",[a._v("可以推送 no-cache 和 no-store 的资源")]),a._v(" "),e("li",[a._v("一旦连接被关闭，Push Cache 就被释放")]),a._v(" "),e("li",[a._v("多个页面可以使用相同的 HTTP/2 连接，也就是说能使用同样的缓存")]),a._v(" "),e("li",[a._v("Push Cache 中的缓存只能被使用一次")]),a._v(" "),e("li",[a._v("浏览器可以拒绝接受已经存在的资源推送")]),a._v(" "),e("li",[a._v("你可以给其他域名推送资源")])]),a._v(" "),e("h2",{attrs:{id:"网络请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络请求"}},[a._v("#")]),a._v(" 网络请求")]),a._v(" "),e("p",[a._v("如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。")]),a._v(" "),e("p",[a._v("那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，接下来我们就来学习缓存策略这部分的内容。")]),a._v(" "),e("h2",{attrs:{id:"_2-缓存策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存策略"}},[a._v("#")]),a._v(" 2. 缓存策略")]),a._v(" "),e("p",[a._v("通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。")]),a._v(" "),e("h3",{attrs:{id:"_2-1-强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-强缓存"}},[a._v("#")]),a._v(" 2.1 强缓存")]),a._v(" "),e("p",[a._v("强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。")]),a._v(" "),e("p",[e("code",[a._v("Expires")]),a._v("在 http 响应中的用法")]),a._v(" "),e("div",{staticClass:"language-http extra-class"},[e("pre",{pre:!0,attrs:{class:"language-http"}},[e("code",[e("span",{pre:!0,attrs:{class:"token header-name keyword"}},[a._v("Expires:")]),a._v(" Wed, 22 Oct 2018 08:41:00 GMT\n")])])]),e("p",[a._v("Expires 是 HTTP/1 的产物，表示资源会在 Wed, 22 Oct 2018 08:41:00 GMT 后过期，需要再次请求。并且 Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。")]),a._v(" "),e("p",[e("code",[a._v("Cache-Control")]),a._v("在 http 响应中的用法")]),a._v(" "),e("div",{staticClass:"language-http extra-class"},[e("pre",{pre:!0,attrs:{class:"language-http"}},[e("code",[e("span",{pre:!0,attrs:{class:"token header-name keyword"}},[a._v("Cache-Control:")]),a._v(" max-age=60;\n")])])]),e("p",[a._v("Cache-Control 出现于 HTTP/1.1，优先级高于 Expires 。该属性值表示资源会在 30 秒后过期，需要再次请求。")]),a._v(" "),e("p",[a._v("Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令")]),a._v(" "),e("div",{staticClass:"language-js extra-class"},[e("pre",{pre:!0,attrs:{class:"language-js"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("let")]),a._v(" directive "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Cache-Control:'")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Reusable response"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 资源可以缓存")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Revalidate each time"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 每次检查缓存资源是否生效")]),a._v("\n    directive "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Cache-Control: no-cache'")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 不每次检查缓存资源是否生效")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("Cache be able by intermediate caches"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 缓存资源可以被HTTP代理缓存")]),a._v("\n      directive "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Cache-Control: public'")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 缓存资源不可以被HTTP代理缓存")]),a._v("\n      directive "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Cache-Control: private'")]),a._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("else")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 资源不可以缓存")]),a._v("\n  directive "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v("'Cache-Control: no-store'")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),e("h3",{attrs:{id:"_2-2-协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-协商缓存"}},[a._v("#")]),a._v(" 2.2 协商缓存")]),a._v(" "),e("p",[a._v("如果缓存过期了，就需要发起请求验证资源是否有更新。协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。")]),a._v(" "),e("p",[a._v("当浏览器发起请求验证资源时，如果资源没有做改变，那么服务端就会返回 304 状态码，并且更新浏览器缓存有效期。")]),a._v(" "),e("p",[a._v("Last-Modified 和 If-Modified-Since: Last-Modified 表示本地文件最后修改日期，If-Modified-Since 会将 Last-Modified 的值发送给服务器，询问服务器在该日期后资源是否有更新，有更新的话就会将新的资源发送回来，否则返回 304 状态码。")]),a._v(" "),e("p",[a._v("但是 Last-Modified 存在一些弊端：")]),a._v(" "),e("ul",[e("li",[a._v("如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源")]),a._v(" "),e("li",[a._v("因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源")])]),a._v(" "),e("p",[a._v("因为以上这些弊端，所以在 HTTP / 1.1 出现了 ETag 。")]),a._v(" "),e("p",[a._v("ETag 和 If-None-Match: ETag 类似于文件指纹，If-None-Match 会将当前 ETag 发送给服务器，询问该资源 ETag 是否变动，有变动的话就将新的资源发送回来。并且 ETag 优先级比 Last-Modified 高。")]),a._v(" "),e("p",[a._v("以上就是缓存策略的所有内容了，看到这里，不知道你是否存在这样一个疑问。如果什么缓存策略都没设置，那么浏览器会怎么处理？")]),a._v(" "),e("p",[a._v("对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间")]),a._v(" "),e("h2",{attrs:{id:"_3-实际场景应用缓存策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-实际场景应用缓存策略"}},[a._v("#")]),a._v(" 3. 实际场景应用缓存策略")]),a._v(" "),e("p",[a._v("单纯了解理论而不付诸于实践是没有意义的，接下来我们来通过几个场景学习下如何使用这些理论。")]),a._v(" "),e("h3",{attrs:{id:"_3-1-频繁变动的资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-频繁变动的资源"}},[a._v("#")]),a._v(" 3.1 频繁变动的资源")]),a._v(" "),e("p",[a._v("对于频繁变动的资源，首先需要使用 Cache-Control: no-cache 使浏览器每次都请求服务器，然后配合 ETag 或者 Last-Modified 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小")]),a._v(" "),e("h3",{attrs:{id:"_3-2-代码文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-代码文件"}},[a._v("#")]),a._v(" 3.2 代码文件")]),a._v(" "),e("p",[a._v("这里特指除了 HTML 外的代码文件，因为 HTML 文件一般不缓存或者缓存时间很短。")]),a._v(" "),e("p",[a._v("一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 Cache-Control: max-age=31536000，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。")]),a._v(" "),e("h2",{attrs:{id:"小结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#小结"}},[a._v("#")]),a._v(" 小结")]),a._v(" "),e("p",[a._v("浏览器缓存按照缓存位置可分为四种：1. Service Worker；2. Memory Cache；3. Disk Cache；4. Push Cache。而请求缓存机制，又可分强缓存和协商缓存，由不同的 HTTP Header 来实现。需要根据具体场景来选择缓存策略。")])])}),[],!1,null,null,null);t.default=r.exports}}]);