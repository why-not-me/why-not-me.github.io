<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>浏览器中的宏任务与微任务 | WangJunMing</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。微任务可以在实时性和效率之间做一个有效的权衡。

从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于 ...">
    
    <link rel="preload" href="/assets/css/0.styles.f63a180a.css" as="style"><link rel="preload" href="/assets/js/app.4f78ac45.js" as="script"><link rel="preload" href="/assets/js/6.a3faf424.js" as="script"><link rel="preload" href="/assets/js/3.c93107eb.js" as="script"><link rel="preload" href="/assets/js/50.60148e16.js" as="script"><link rel="prefetch" href="/assets/js/10.392935be.js"><link rel="prefetch" href="/assets/js/11.811a1c66.js"><link rel="prefetch" href="/assets/js/12.10959571.js"><link rel="prefetch" href="/assets/js/13.0fb2f0c4.js"><link rel="prefetch" href="/assets/js/14.4e95d46b.js"><link rel="prefetch" href="/assets/js/15.6444689d.js"><link rel="prefetch" href="/assets/js/16.4822ee32.js"><link rel="prefetch" href="/assets/js/17.69db6a71.js"><link rel="prefetch" href="/assets/js/18.487e22b5.js"><link rel="prefetch" href="/assets/js/19.d4005a46.js"><link rel="prefetch" href="/assets/js/20.d425f606.js"><link rel="prefetch" href="/assets/js/21.410819d5.js"><link rel="prefetch" href="/assets/js/22.e8d9d6c8.js"><link rel="prefetch" href="/assets/js/23.5137aa0a.js"><link rel="prefetch" href="/assets/js/24.4a43e957.js"><link rel="prefetch" href="/assets/js/25.90ac7b99.js"><link rel="prefetch" href="/assets/js/26.eef39229.js"><link rel="prefetch" href="/assets/js/27.84b1618e.js"><link rel="prefetch" href="/assets/js/28.ea0c286e.js"><link rel="prefetch" href="/assets/js/29.3eddc3b0.js"><link rel="prefetch" href="/assets/js/30.7b9b3561.js"><link rel="prefetch" href="/assets/js/31.d5150dee.js"><link rel="prefetch" href="/assets/js/32.5a8242c0.js"><link rel="prefetch" href="/assets/js/33.e2609257.js"><link rel="prefetch" href="/assets/js/34.c3ea21e1.js"><link rel="prefetch" href="/assets/js/35.19fdd4f5.js"><link rel="prefetch" href="/assets/js/36.54c52f58.js"><link rel="prefetch" href="/assets/js/37.af980e6b.js"><link rel="prefetch" href="/assets/js/38.61d14197.js"><link rel="prefetch" href="/assets/js/39.e8ef2b39.js"><link rel="prefetch" href="/assets/js/4.115d212f.js"><link rel="prefetch" href="/assets/js/40.06e8672d.js"><link rel="prefetch" href="/assets/js/41.a4dec16c.js"><link rel="prefetch" href="/assets/js/42.f5608e4f.js"><link rel="prefetch" href="/assets/js/43.14b35bca.js"><link rel="prefetch" href="/assets/js/44.9e657472.js"><link rel="prefetch" href="/assets/js/45.8aa127f9.js"><link rel="prefetch" href="/assets/js/46.01d25249.js"><link rel="prefetch" href="/assets/js/47.ca96eb82.js"><link rel="prefetch" href="/assets/js/48.fa475f50.js"><link rel="prefetch" href="/assets/js/49.7446c092.js"><link rel="prefetch" href="/assets/js/5.264a5b6a.js"><link rel="prefetch" href="/assets/js/51.f4a2daa7.js"><link rel="prefetch" href="/assets/js/52.ff4c76b2.js"><link rel="prefetch" href="/assets/js/53.eb3706e3.js"><link rel="prefetch" href="/assets/js/54.cc25c1c7.js"><link rel="prefetch" href="/assets/js/55.a2083f52.js"><link rel="prefetch" href="/assets/js/7.e5b64fb2.js"><link rel="prefetch" href="/assets/js/8.efd2d38a.js"><link rel="prefetch" href="/assets/js/9.1e3eed58.js"><link rel="prefetch" href="/assets/js/vuejs-paginate.0f8d5620.js">
    <link rel="stylesheet" href="/assets/css/0.styles.f63a180a.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div id="vuepress-theme-blog__global-layout"><section id="header-wrapper"><header id="header"><div class="header-wrapper"><div class="title"><a href="/" class="nav-link home-link">WangJunMing </a></div> <div class="header-right-wrap"><ul class="nav"><li class="nav-item"><a href="/" class="nav-link">Blog</a></li><li class="nav-item"><a href="/tag/" class="nav-link">Tags</a></li></ul> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></div></header></section> <div id="mobile-header"><div class="mobile-header-bar"><div class="mobile-header-title"><a href="/" class="nav-link mobile-home-link">WangJunMing </a> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg></div> <div class="mobile-menu-wrapper"><hr class="menu-divider"> <ul class="mobile-nav"><li class="mobile-nav-item"><a href="/" class="nav-link">Blog</a></li><li class="mobile-nav-item"><a href="/tag/" class="nav-link">Tags</a></li> <li class="mobile-nav-item"><!----></li></ul></div></div></div> <div class="content-wrapper"><div id="vuepress-theme-blog__post-layout"><article itemscope="itemscope" itemtype="https://schema.org/BlogPosting" class="vuepress-blog-theme-content"><header><h1 itemprop="name headline" class="post-title">
        浏览器中的宏任务与微任务
      </h1> <div class="post-meta"><div itemprop="publisher author" itemtype="http://schema.org/Person" itemscope="itemscope" class="post-meta-author"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-navigation"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg> <span itemprop="name">WangJunMing</span> <span itemprop="address">   in ShangHai</span></div> <div class="post-meta-date"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-clock"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg> <time pubdate itemprop="datePublished" datetime="2020-04-12T00:00:00.000Z">
      Sun Apr 12 2020
    </time></div> <ul itemprop="keywords" class="post-meta-tags"><li class="post-tag" data-v-42ccfcd5><a href="/tag/浏览器" data-v-42ccfcd5><span data-v-42ccfcd5>浏览器</span></a></li></ul></div></header> <div itemprop="articleBody" class="content__default"><p>随着浏览器的应用领域越来越广泛，消息队列中这种粗时间颗粒度的任务已经不能胜任部分领域的需求，所以又出现了一种新的技术——微任务。微任务可以在实时性和效率之间做一个有效的权衡。</p> <p>从目前的情况来看，微任务已经被广泛地应用，基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。所以微任务的重要性也与日俱增，了解其底层的工作原理对于我们读懂别人的代码，以及写出更高效、更具现代的代码有着决定性的作用。</p> <h2 id="宏任务"><a href="#宏任务" class="header-anchor">#</a> 宏任务</h2> <p>页面中的大部分任务都是在主线程上执行的，这些任务包括了：</p> <ul><li>渲染事件（如解析 DOM、计算布局、绘制）；</li> <li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）；</li> <li>JavaScript 脚本执行事件；</li> <li>网络请求完成、文件读写完成事件。</li></ul> <p>为了协调这些任务有条不紊地在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中和延迟队列中的任务都称为宏任务。</p> <p>WHATWG 是这样定义事件循环机制的：</p> <ol><li>先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask；</li> <li>然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务；</li> <li>当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask；</li> <li>最后统计执行完成的时长等信息。</li></ol> <p>以上就是消息队列中宏任务的执行过程。宏任务可以满足我们大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，下面我们就来分析下为什么宏任务难以满足对时间精度要求较高的任务。</p> <p>页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。比如之前提过的，setTimeout 并不能保证回调函数在设置的延延时后执行，因为可能会被其他任务插队。</p> <p>所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如 监听 DOM 变化的需求。</p> <h2 id="微任务"><a href="#微任务" class="header-anchor">#</a> 微任务</h2> <p>异步回调有两种实现机制：</p> <ol><li>第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解，setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。</li> <li>第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。</li></ol> <p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p> <p>当 JavaScript 执行一段脚本的时候，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。顾名思义，这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以你是无法通过 JavaScript 直接访问的</p> <p>也就是说每个宏任务都关联了一个微任务队列。那有两个重要时机需要关注，即微任务的产生时机和执行微任务的时机。</p> <p>那微任务是怎么产生扽？在现代浏览器里面，产生微任务有两种方式。</p> <ol><li>使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。</li> <li>使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。</li></ol> <p>通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。</p> <p>好了，现在微任务队列中有了微任务了，那接下来就要看看微任务队列是何时被执行的。</p> <p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。</p> <p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p> <p>从微任务工作流程，可以知道：</p> <ol><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。</li> <li>微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。所以你在写代码的时候一定要注意控制微任务的执行时长。</li> <li>在一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。</li></ol> <h2 id="监听-dom-变化的演变"><a href="#监听-dom-变化的演变" class="header-anchor">#</a> 监听 DOM 变化的演变</h2> <p>现在知道了微任务是怎么工作的，那接下来我们再来看看微任务是如何应用在 MutationObserver 中的。MutationObserver 是用来监听 DOM 变化的一套方法，而监听 DOM 变化一直是前端工程师一项非常核心的需求。</p> <p>多 Web 应用都利用 HTML 与 JavaScript 构建其自定义控件，与一些内置控件不同，这些控件不是固有的。为了与内置控件一起良好地工作，这些控件必须能够适应内容更改、响应事件和用户交互。因此，Web 应用需要监视 DOM 变化并及时地做出响应。</p> <p>虽然监听 DOM 的需求是如此重要，不过早期页面并没有提供对监听的支持，所以那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。</p> <p>直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。</p> <p>采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里我们假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。</p> <p>也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。</p> <p>为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。</p> <p>MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。</p> <p>通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面我们分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。</p> <p>这时候，微任务就可以上场了，在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。</p> <p>综上所述， MutationObserver 采用了“异步 + 微任务”的策略。</p></div> <footer><!----> <hr> <!----></footer></article> <div class="sticker vuepress-toc"><div class="vuepress-toc-item vuepress-toc-h2 active"><a href="#宏任务" title="宏任务">宏任务</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#微任务" title="微任务">微任务</a></div><div class="vuepress-toc-item vuepress-toc-h2"><a href="#监听-dom-变化的演变" title="监听 DOM 变化的演变">监听 DOM 变化的演变</a></div></div></div></div> <footer class="footer" data-v-3d9deeb8><div class="footer-left-wrap" data-v-3d9deeb8><ul class="contact" data-v-3d9deeb8></ul></div> <div class="footer-right-wrap" data-v-3d9deeb8><ul class="copyright" data-v-3d9deeb8></ul></div></footer></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.4f78ac45.js" defer></script><script src="/assets/js/6.a3faf424.js" defer></script><script src="/assets/js/3.c93107eb.js" defer></script><script src="/assets/js/50.60148e16.js" defer></script>
  </body>
</html>
