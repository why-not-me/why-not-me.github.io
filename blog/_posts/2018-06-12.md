---
title: js内存如何存储数据
date: 2018-06-12
author: WangJunMing
location: HangZhou
tags:
  - JavaScript
---

js 的内存机制，对不少前端开发者而言，似乎是个黑盒，因为很少有资料书提及，所以非常容易被忽略。

但是不懂 js 的内存机制，很容易写出不那么优雅的代码，甚至有时候都不知道该怎么排查错误。虽然 js 不似 C 语言，需要人主动管理内存，但是为了避免实际项目中的一些不必要的坑，还是很有必要了解数据在内存中的存储方式的。

看个简单的例子

```js
function foo() {
  var a = 1;
  var b = a;
  a = 2;
  console.log(a);
  console.log(b);
}
function bar() {
  var a = { name: 'bar' };
  var b = a;
  a.name = 'newBar';
  console.log(a);
  console.log(b);
}
bar();
```

可以发现，`foo()`执行后，`a`为 2，`b`还是 1；但是`bar()`执行后，`a`变成了`{name: 'newBar'}`，`b`却也变成了`{name: 'newBar'}`。

要理解这个现象，我们先得了解，js 是什么类型的语言。

## js 是什么类型的语言

如果学 C 或者 java，我们会知道，一个变量在使用之前就要确定其数据类型，这种我们称之为**静态语言**。而 js 这种，则是在运行过程中再检查变量的数据类型，所以被称之为**动态语言**。

虽然 C 是静态语言，但是在 C 语言中，我们可以把其他类型的数据赋予给一个声明好的变量，比如我们把 int 型的变量 a，赋值给了 bool 型的变量 c，那么也是可以编译执行的。因为在赋值过程中，C 编译器会悄悄将 int 型变量 a 的值，悄悄转换为 bool 值，再将转化后的 bool 值，赋值给 bool 型的变量 c。这种编译器做的悄悄转换，被称为为**隐式类型转换**，而支持隐式类型转换的语言称之为**弱类型语言**，比如 C 语言、js；而不支持隐式转换的的语言，则有 java、ts、C#。

综上所述，js 就是一种弱类型、动态的语言，所以 js 的特点正如这两种形式描述的

1. 弱类型，意味着声明变量时，不需要声明该变量是什么数据类型，js 引擎在运行时动态判断
2. 动态，意味这可以使用一个变量，保存不同类型的数据

而 js 的数据类型，在之前的文章里说过了，这里再复习一遍，分别是`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`Object`，还有一种新出的数字类型`Bigint`，可以用任意精度存储数字。在使用`Bigint`时，即使`Number`的安全整数限制，也可以安全存储数字和操作数字。

一般把`Number`、`String`、`Boolean`、`Undefined`、`Null`、`Symbol`、`Bigint`这七种称之为原始类型，把`Object`称之为引用类型。之所以这样区分，是因为它们在 js 内存中存放的位置不一样。

## js 的内存空间

要理解 js 在运行过程如何存储数据的，就得先搞清楚其存储空间的种类。

js 在执行过程中，主要有三种类型内存空间，分别是

1. 代码空间
2. 栈空间
3. 堆空间

其中代码空间主要是用来存储可执行的代码的，和数据的存储没关系。所以主要讨论的是栈空间和堆空间。

这里的栈空间就是函数调用栈，用来存储执行上下文的。那么栈空间是如何存储数据的，看以下代码

```js
function foo() {
  var a = 'foo';
  var b = a;
  var c = { name: 'bar' };
  var d = c;
}
foo();
```

之前文章讨论过，js 执行一段代码时，要先编译，并创建执行上下文，然后按照顺序执行。所以执行`foo()`时，当执行到`var b = a`时，此时的函数调用栈是如下的情况：

调用栈（call stack）存储着两个执行上下文，一个是全局执行上下文，一个是 foo 函数的执行上下文。foo 函数执行上下文中，变量环境维持了一个变量栈，变量栈中，因变量提升的缘故，放着四个变量，从栈顶开始依次是`a b c d`。其中 a 和 b 存储的数据类型是字符串，c 和 d 因为还没赋值，此时还只是`undefined`。因为 a 和 b 保存在执行上下文中，而执行上下文又是在栈中，所以可以认为 a 和 b 是保存在栈中的

继续向下执行，当执行`var c = { name: 'bar' }`时，js 引擎会判断`{ name: 'bar' }`是个引用类型的值，这个时候的处理情况，js 引擎并不会将这个对象直接存放到变量环境中，而是将它分配到堆空间里，分配好后该对象会拥有一个‘堆’的地址，js 引擎会将这个地址的数据，写入到变量 c 中，同理，变量 d 存储的也是一个‘堆’的地址。

所以，对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。

至此，我们就能明确：原始类型的值是存储在栈空间的（call stack）,而引用类型的值（一般是对象）是存储在堆空间的。不过为什么一定要分栈空间和堆空间呢，所有的数据直接放在栈空间不好吗？

当然是不合适的。因为 js 引擎需要使用调用栈来维护程序执行期间上下文的状态，如果栈空间大了的话，所有数据全存储在栈空间，会严重影响到 js 引擎切换上下文的效率，进而影响到整个程序的效率。

所以通常情况下，栈空间不会设置太大，主要用来存放一些原始类型的小数据，而引用类型的数据比较占空间，一般会分配到堆空间保存。堆空间很大，能存放很多数据，不过分配内存和回收内存，都会占用一定时间。

因为 c 变量存放的只是对象所在堆空间的地址，所以能看出来，js 中的赋值操作和其他语言不太一样：原始类型的赋值会完整复制变量的数据值，而引用类型的赋值只是将应用类型数据所在堆空间的地址复制了一遍。

## 小结

原始类型的数据是存放在栈中，引用类型的数据是存放在堆中的。堆中的数据是通过引用和变量关联起来的。也就是说，js 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。

在 js 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。
